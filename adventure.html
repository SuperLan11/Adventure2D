<! --
		class for drawing
		class for hero
		class for enemies
		class for potions
		
		only global variables for:
			canvas object
			context2D			
			main
			
		Local variables for hero, enemies, potion, and environment in draw class:
			Put predetermined number of enemies and potions into lists of the draw class. Their attribute will be accesible from the list.
			Instantiate hero
			
			2d environment list with grid. 
			Empty positions are 0
			hero is H
			golem is G
			snowman is S
			void is V
			B is brick
			T is tree. 
			If not null, drawBrick at indexes for x, y
			
			put keydown function in draw class?
		
		updaing enemy:
			get list of adjacent tiles that don't have an obstacle or hero. isObstacle function?
			randomly pick an adjacent tile from the list
			call move function that incremenets/decrements position based on what tile was chosen
			update and render enemy
			
		update hero:
			same thing, but if hero moves to enemy (after enemy moves), maintain position and lower enemy health
			
			
		when arrow key pressed, update and render hero, enemies, and potions (delete potions if hero moves to them). Don't forget hp bars
		render both the hero/enemy and their health bar		
		
		draw grid lines later
		
		hierarchy:
			Entity (brick, tree)
				character
					hero
					monster							
-- >

<!doctype html>
<html>
	<script>				
		/*class Entity
		{
		
			x;
			y;	

			constructor()
			{
				this.x = 0;
				this.y = 0;
			}			
			
			// assumes canvas cleared already 
			// redraw entity at x, y
			// then redraw hp bar
						
			render(type)
			{								
				if(type === 'B')
				{
					gameMain.drawBrick(this.x, this.y);
				}
				else if(type === 'T')
				{
					gameMain.drawTree(this.x, this.y);
				}
			}
		}		*/	
		
		class Character
		{	
			x;
			y;
			
			hp;
			maxHp;
			
			atk;
			def;
			
			pic;
			
			constructor()
			{							
				this.x = 0;
				this.y = 0;
				
				this.hp = 100;
				this.maxHp = 100;
				this.atk = 1;
				this.def = 1;

				this.pic = new Image();
			}
		
			update(moveX, moveY, hpChange)
			{
				this.x += moveX;
				this.y += moveY;
				this.hp += hpChange;
			}
			
			render()
			{				
				context.drawImage(this.pic, this.x, this.y, 64, 64);			
			}
			
		}
		
		class Hero extends Character
		{					
			constructor()
			{
				super();	
				
				this.pic = new Image();
				this.pic.src = "img/hero.png";				
			}						
		}
				
		class Monster extends Character
		{					
			constructor()
			{	
				super();														
				
				this.pic = new Image();				
			}					
		}
		
		class main
		{
			hero;
			monsters = [];
			grid = [ 
			['B', 'T', 'B', 'T', 'B', 'T', 'B', 'T', 'B', 'T'],
			['B', 'H', 'B', 'G', 0, 0, 0, 0, 0, 'B'],
			['B', 0, 'T', 'T', 0, 0, 0, 'B', 0, 'T'],
			['T', 0, 0, 0, 0, 'T', 0, 0, 0, 'B'],
			['B', 0, 0, 0, 0, 'B', 'V', 'B', 0, 'T'],
			['T', 'B', 'T', 0, 0, 0, 0, 'T', 0, 'B'],
			['B', 'S', 0, 0, 0, 0, 0, 0, 0, 'T'],
			['T', 0, 0, 0, 0, 0, 0, 0, 0, 0] 			
			];
			canvasWidth;
			canvasHeight;
			
			constructor()
			{				
				this.hero = new Hero();
				
				this.canvasWidth = document.getElementsByTagName("canvas")[0].width;
				this.canvasHeight = document.getElementsByTagName("canvas")[0].height;											
								
				this.drawGrid();							
			}
			
			drawGrid()
			{			
				// make potions here later			
				
				for(let row = 0; row < this.grid.length; row++)
				{
					for(let col = 0; col < this.grid[row].length; col++)
					{
						 /*cases:
							create brick, tree entity with x and y, render, then break
							create hero with x and y, render, then break
							create monster with x and y, render, then breal
							
							override render method in character class													
						*/															
						
						switch(this.grid[row][col])
						{							
							case 'B':								
								this.drawBrick(row, col);
								break;
							case 'T':								
								this.drawTree(row, col);
								break;
							case 'H':
								var hero = new Hero();
								hero.render();
								break;
							case 'S':
								this.monsters.push(new Monster());
								this.monsters[this.monsters.length-1].pic.src = "img/snowMonster.png";
								this.monsters[this.monsters.length-1].render();
								this.monsters[this.monsters.length-1].x = col * 64;
								this.monsters[this.monsters.length-1].y = row * 64;								
								break;
							case 'V':
								this.monsters.push(new Monster());
								this.monsters[this.monsters.length-1].pic.src = "img/skullMonster.png";
								this.monsters[this.monsters.length-1].render();
								this.monsters[this.monsters.length-1].x = col * 64;
								this.monsters[this.monsters.length-1].y = row * 64;
								break;
							case 'G':
								this.monsters.push(new Monster());
								this.monsters[this.monsters.length-1].pic.src = "img/iceGolem.png";
								this.monsters[this.monsters.length-1].render();
								this.monsters[this.monsters.length-1].x = col * 64;
								this.monsters[this.monsters.length-1].y = row * 64;
								break;								
						}
					}
				}								
			}
			
			clearCanvas()
			{				
				context.clearRect(0, 0, canvas.width, canvas.height);
			}
			
			setLineColor(color)
			{
				context.strokeStyle = color;
			}
			
			setFillColor(color)
			{
				context.fillStyle = color;
			}
			
			setLineWidth(width)
			{
				context.lineWidth = width;
			}
			
			setLineCap(str)
			{
				// options are butt, round, square
				context.lineCap = str;								
			}
			
			setLineJoin(c)
			{
				switch(c)
				{
					case 0: 
							context.lineJoin = "miter";
							break;
					case 1:
							context.lineJoin = "round";
							break;
					case 2:
							context.lineJoin = "bevel";
							break;
					default:
							break;
				}
			}					
			
			drawLine(x1, y1, x2, y2)
			{
				this.setLineWidth(1);
				this.setLineColor("#F00");
				this.setLineCap(0);
				
				context.beginPath();
				context.moveTo(x1,y1);
				context.lineTo(x2,y2);
				context.stroke();
			}
			
			drawBrick(x, y)
			{
				this.setLineWidth(32);
				this.setLineColor("#BC4A3C");
				this.setLineCap("square");
				
				// should be 64x64 px
				
				context.beginPath();
				context.moveTo(x*64, y*64);
				context.lineTo(x*64 + 64, y*64);
				context.stroke();
			}
						
			drawTree(x, y)
			{
				this.setLineWidth(12);				
				this.setLineCap("round");
										
				// draw trunk
				context.beginPath();
				this.setLineColor("#a69f6c");
				context.moveTo(x*64 + 32, y*64);
				context.lineTo(x*64 + 32, y*64 - 32);
				context.moveTo(x*64 + 32, y*64 - 32);
				context.stroke();
				
				// draw leaves
				context.beginPath();
				this.setLineWidth(50);
				this.setLineColor("#45ad57");						
				context.lineTo(x*64 + 32, y*64 - 48);
				context.moveTo(x*64 + 32, y*64 - 48);
				context.stroke();				

				// add tree to 2d arr here or in advance?
			}
			
			// why not working?
			drawImages()
			{								
				this.hero.render();					
				this.monsters[0].render();														
			}									
		}
	</script>
		
	<canvas width=640 height=512 style="border: solid; border-color: black;">				
	</canvas>			
	
	<script>	
		var canvas = document.getElementsByTagName("canvas")[0];
		var context = canvas.getContext("2d");		
		var gameMain = new main();		
		
		/*
		use drawGrid to initialize, then rely on update and render functions
		*/
		
		document.onkeydown = function(event)
		{			
			gameMain.clearCanvas();
			
			switch (event.keyCode) 
			{
				// left
				case 37:					
					gameMain.hero.update(-64, 0, 0);
					gameMain.hero.render();									
					break;
				// up
				case 38:									
					gameMain.hero.update(0, -64, 0);
					gameMain.hero.render();					
					break;
				// right
				case 39:					
					gameMain.hero.update(64, 0, 0);
					gameMain.hero.render();									
					break;
				// down
				case 40:							
					gameMain.hero.update(0, 64, 0);
					gameMain.hero.render();									
					break;
			}				
			
			gameMain.drawGrid();
						
			for(let i = 0; i < gameMain.monsters.length; i++)
			{
				gameMain.monsters[i].update(0, 0, 0);				
				gameMain.monsters[i].render();
			}			
		};
	</script>
</html>

