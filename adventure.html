<! --
		class for drawing
		class for hero
		class for enemies
		class for potions
		
		only global variables for:
			canvas object
			context2D			
			main		
			
		update hero:
			same thing, but if hero moves to enemy (after enemy moves), maintain position and lower enemy health
									
		
		hierarchy:
			Potion
			Character
				Hero
				// for move
				Monster
					// for renders
					Snowman 
					Void
					Golem
							
		Combat stuff:
			if hero and enemy move to same tile, enemy stays and both attack
			if hero and enemy both move and are adjacent after, both attack
			if enemy moves into obstacle and hero moves beside enemy, hero attack. vice versa for hero
			if enemy and hero both move into each other, both attack
			if enemy moves away from hero and hero chases enemy, hero attack
			
			enemy should stay still if hero moves to same tile
			enemy should stay still if hero and enemy move to each other
			
			hero updates and renders before enemies
				
		TODO:		
			Fix player taking damage at weird times
			Delete hero if dead						
			DRAW GRID AND SHRINK IMAGES
-- >

<!doctype html>
<html>
	<script>						
		class Character
		{	
			x;
			y;
			
			hp;
			maxHp;
			
			atk;
			def;			

			pic;
			
			constructor()
			{							
				this.x = 1;
				this.y = 1;								
			}			

			drawHealth()
			{
				gameMain.setLineWidth(5);				
				gameMain.setLineCap("butt");
				
				let hpPercent = this.hp/this.maxHp;		

				if(hpPercent > 0.6)
				{
					gameMain.setLineColor("#0F0");
				}
				else if(hpPercent > 0.25)
				{
					gameMain.setLineColor("#FF0");
				}
				else if(hpPercent > 0)
				{
					gameMain.setLineColor("#F00");
				}				
				
				context.beginPath();
				context.moveTo(64 * this.x + 12, 64 * this.y + 4);
				context.lineTo(64 * this.x + 12 + 40*hpPercent, 64 * this.y + 4);
				context.stroke();
			}
			
			getRandomInt(max)
			{	
				return Math.floor(Math.random()*(max+1));
			}		
			
			attack(character)
			{						
				let statDiff = this.atk - character.def;
				let max = Math.max(1, statDiff);
				let damage = max*(1 + this.getRandomInt(5));
				
				character.hp -= damage;
				if(character.hp <= 0)				
				{								
					// delete monster if dead
					gameMain.monsters = gameMain.monsters.filter(function(value) 
					{
						return value !== character;
					});
				}
			}
			
			render()
			{					
				// will character still exist on grid after death?
				if(this.hp > 0)
				{
					context.drawImage(this.pic, 64 * this.x, 64 * this.y, 64, 64);	
					this.drawHealth();				
				}
			}
		}
		
		class Hero extends Character
		{			
			constructor()
			{
				super();	
				
				this.x = 1;
				this.y = 1;
				
				this.hp = 100;
				this.maxHp = 100;
				
				this.atk = 6;
				this.def = 3;
				
				this.pic = new Image();
				this.pic.src = "img/hero.png";				
			}			
			
			update(key)
			{	
				// left
				if(key == 37 && gameMain.grid[this.y][(this.x-1)] == 0)
				{
					if(gameMain.tileHasCharacter(this.x-1, this.y))
					{
						this.attack(gameMain.getCharacter(this.x-1, this.y));
					}
					else
					{
						this.x -= 1;
					}
				}
				// up
				else if(key == 38 && gameMain.grid[(this.y-1)][this.x] == 0)
				{
				    if(gameMain.tileHasCharacter(this.x, this.y-1))
					{
						this.attack(gameMain.getCharacter(this.x, this.y-1));
					}
					else
					{
						this.y -= 1;
					}
				}
				// right
				else if(key == 39 && gameMain.grid[this.y][(this.x+1)] == 0)
				{
				    if(gameMain.tileHasCharacter(this.x+1, this.y))
					{
						this.attack(gameMain.getCharacter(this.x+1, this.y));
					}
					else
					{
						this.x += 1;
					}
				}
				// down
				else if(key == 40 && gameMain.grid[(this.y+1)][this.x] == 0)						
				{
					if(gameMain.tileHasCharacter(this.x, this.y+1))
					{
						this.attack(gameMain.getCharacter(this.x, this.y+1));
					}
					else
					{
						this.y += 1;
					}
				}				

				if(gameMain.tileHasPotion(this.x, this.y))
				{
					let potion = gameMain.getPotion(this.x, this.y);
					
					// add health up to max
					if(this.hp + Potion.hpBoost > this.maxHp)	
					{						
						this.hp = this.maxHp;
					}
					else
					{					
						this.hp += Potion.hpBoost;
					}
						
					// delete potion										
					gameMain.potions = gameMain.potions.filter(function(value) 
					{
						return value !== potion;
					});
				}
			}					
		}
		
		class Monster extends Character
		{
			constructor()
			{
				super();
				
				this.x = 0;
				this.y = 0;
				
				this.hp = 100;
				this.maxHp = 100;
				
				this.atk = 3;
				this.def = 2;							
			}					
			
			update()
			{				
				let adjTiles = [];				
				
				// could use a list of tile offsets to make more concise
				if(gameMain.tileHasCharacter(this.x, this.y-1))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.grid[(this.y-1)][this.x] == 0)
				{
					adjTiles.push("top");
				}
				
				if(gameMain.tileHasCharacter(this.x+1, this.y))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.grid[this.y][this.x+1] == 0)
				{
					adjTiles.push("right");
				}
				
				if(gameMain.tileHasCharacter(this.x, this.y+1))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.grid[(this.y+1)][this.x] == 0)
				{
					adjTiles.push("bottom");
				}
				
				if(gameMain.tileHasCharacter(this.x-1, this.y))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.grid[this.y][this.x-1] == 0)
				{
					adjTiles.push("left");
				}																		
											
				let randIndx = this.getRandomInt(adjTiles.length);				
				
				switch(adjTiles[randIndx])
				{
					case "top":
						this.y -= 1;
						break;
					case "right":
						this.x += 1;
						break;
					case "bottom":
						this.y += 1;
						break;
					case "left":
						this.x -= 1;						
						break;
					case "hero":
						this.attack(gameMain.hero);
						break;
				}							
			}
		}
		
		class Snowman extends Monster
		{
			constructor()
			{
				super();
				
				this.x = 1;
				this.y = 6;
				
				this.hp = 100;
				this.maxHp = 100;
				
				this.atk = 3;	
				this.def = 3;		
				
				this.pic = new Image();
				this.pic.src = "img/snowMonster.png";
			}			
		}
		
		class Golem extends Monster
		{
			constructor()
			{
				super();
				
				this.x = 3;
				this.y = 1;
				
				this.hp = 100;
				this.maxHp = 100;
				
				this.atk = 3;
				this.def = 4;		
				
				this.pic = new Image();
				this.pic.src = "img/iceGolem.png";
			}			
		}
		
		class Void extends Monster
		{
			constructor()
			{
				super();
				
				this.x = 7;
				this.y = 3;
				
				this.hp = 80;
				this.maxHp = 80;
				
				this.atk = 5;
				this.def = 2;		
				
				this.pic = new Image();
				this.pic.src = "img/skullMonster.png";
			}			
		}
		
		class Potion
		{
			x;
			y;
			static hpBoost = 50;
			
			pic;
			
			constructor()
			{				
				this.pic = new Image();
				this.pic.src = "img/potion.png";
			}
			
			render()
			{							
				context.drawImage(this.pic, 64 * this.x + 10, 64 * this.y + 16, 44, 44);												
			}
		}
		
		class main
		{
			hero;
			monsters = [];
			potions = [];
			grid = [ 
			['B', 'T', 'B', 'T', 'B', 'T', 'B', 'T', 'B', 'T'],
			['B', 0, 'B', 0, 0, 0, 0, 0, 0, 'B'],
			['B', 0, 'T', 'T', 0, 0, 0, 'B', 0, 'T'],
			['T', 0, 0, 0, 0, 'T', 0, 0, 0, 'B'],
			['B', 0, 0, 0, 0, 'B', 0, 'B', 0, 'T'],
			['T', 'B', 'T', 0, 0, 0, 0, 'T', 0, 'B'],
			['B', 0, 0, 0, 0, 0, 0, 0, 0, 'T'],
			['T', 'B', 'T', 'B', 'T', 'B', 'T', 'B', 'T', 'B'] 			
			];
			gameWon;
			canvasWidth;
			canvasHeight;
			
			constructor()
			{						
				this.hero = new Hero();
				this.monsters.push(new Snowman());
				this.monsters.push(new Golem());
				this.monsters.push(new Void());
				
				this.potions.push(new Potion());
				this.potions[0].x = 8;
				this.potions[0].y = 6;
				
				this.potions.push(new Potion());
				this.potions[1].x = 5;
				this.potions[1].y = 1;
				
				this.gameWon = false;
				
				this.canvasWidth = document.getElementsByTagName("canvas")[0].width;
				this.canvasHeight = document.getElementsByTagName("canvas")[0].height;																									
			}
			
			// returns x and y of first match to valueToFind
			getGridPosition(valueToFind) 
			{
				for (let i = 0; i < this.grid.length; i++) 
				{
					for (let j = 0; j < this.grid[i].length; j++) 
					{
						if (this.grid[i][j] === valueToFind)
							return { row: i, col: j };						
					}
				}				
				return null;
			}							
				
			getCharacter(x, y)
			{
				if(this.hero.x == x && this.hero.y == y)
					return this.hero;
					
				for(let i = 0; i < this.monsters.length; i++)
				{
					if(this.monsters[i].x == x && this.monsters[i].y == y)
						return this.monsters[i];
				}
				
				return "character not found";
			}
			
			getPotion(x, y)
			{
				for(let i = 0; i < this.potions.length; i++)
				{
					if(this.potions[i].x == x && this.potions[i].y == y)
						return this.potions[i];
				}
				
				return "potion not found";
			}
			
			drawBackground()
			{				
				this.setLineWidth(1000);
				this.setLineColor("#eef0bd");
				this.setLineCap("square");
				
				context.beginPath();
				context.moveTo(this.canvasWidth/2, this.canvasHeight/2);
				context.lineTo((this.canvasWidth/2)+1, (this.canvasHeight/2)+1);
				context.stroke();
			}
			
			drawObstacles()
			{
				for(let row = 0; row < this.grid.length; row++)
				{
					for(let col = 0; col < this.grid[row].length; col++)
					{
						switch(this.grid[row][col])
						{							
							case 'B':								
								this.drawBrick(col, row);
								break;
							case 'T':								
								this.drawTree(col, row);
								break;
						}
					}
				}
			}

			tileHasCharacter(x, y)
			{
				for(let i = 0; i < this.monsters.length; i++)
				{
					if(this.monsters[i].x == x && this.monsters[i].y == y)
						return true;
					if(this.hero.x == x && this.hero.y == y)
						return true;
				}
				return false;
			}
			
			tileHasPotion(x, y)
			{
				for(let i = 0; i < this.potions.length; i++)
				{
					if(this.potions[i].x == x && this.potions[i].y == y)
						return true;
				}
				return false;
			}
			
			updateMonsters()
			{
				for(let i = 0; i < this.monsters.length; i++)				
					this.monsters[i].update();
					
				if(this.monsters.length == 0)
					this.gameWon = true;
			}	
			
			renderMonsters()
			{
				for(let i = 0; i < this.monsters.length; i++)				
					this.monsters[i].render();
			}
			
			renderPotions()
			{
				for(let i = 0; i < this.potions.length; i++)				
					this.potions[i].render();			
			}
			
			clearCanvas()
			{								
				context.clearRect(0, 0, canvas.width, canvas.height);
			}
			
			setLineColor(color)
			{
				context.strokeStyle = color;
			}
			
			setFillColor(color)
			{
				context.fillStyle = color;
			}
			
			setLineWidth(width)
			{
				context.lineWidth = width;
			}
			
			setLineCap(str)
			{
				// options are butt, round, square
				context.lineCap = str;								
			}
			
			setLineJoin(c)
			{
				switch(c)
				{
					case 0: 
							context.lineJoin = "miter";
							break;
					case 1:
							context.lineJoin = "round";
							break;
					case 2:
							context.lineJoin = "bevel";
							break;
					default:
							break;
				}
			}					
			
			drawLine(x1, y1, x2, y2)
			{
				this.setLineWidth(1);
				this.setLineColor("#F00");
				this.setLineCap(0);
				
				context.beginPath();
				context.moveTo(x1,y1);
				context.lineTo(x2,y2);
				context.stroke();
			}
			
			drawBrick(x, y)
			{
				this.setLineWidth(32);
				this.setLineColor("#BC4A3C");
				this.setLineCap("square");					
				
				context.beginPath();
				context.moveTo(x*64 + 20, (y+1)*64 - 22);
				context.lineTo(x*64 + 44, (y+1)*64 - 22);
				context.stroke();				
			}
						
			drawTree(x, y)
			{
				this.setLineWidth(10);				
				this.setLineCap("round");
										
				// draw trunk
				context.beginPath();
				this.setLineColor("#a69f6c");
				context.moveTo(x*64 + 32, (y+1)*64);
				context.lineTo(x*64 + 32, (y+1)*64 - 22);
				context.moveTo(x*64 + 32, (y+1)*64 - 22);
				context.stroke();
				
				// draw leaves
				context.beginPath();
				this.setLineWidth(45);
				this.setLineColor("#45ad57");						
				context.lineTo(x*64 + 32, (y+1)*64 - 42);
				context.moveTo(x*64 + 32, (y+1)*64 - 42);
				context.stroke();						
				// add tree to 2d arr here or in advance?
			}				

			drawWinScreen()
			{				
				let fontSize = 110;
				context.font = fontSize + 'px Arial';
				context.fillStyle = 'black';						
				
				let xOffset = this.canvasWidth/(fontSize/18);
				
				var message = 'You win!';
				context.fillText(message, xOffset, this.canvasHeight/2 + 20);
			}
		}
	</script>
		
	<canvas width=640 height=512 style="border: solid; border-color: black;">				
	</canvas>			
	
	<script>	
		var canvas = document.getElementsByTagName("canvas")[0];
		var context = canvas.getContext("2d");		
		var gameMain = new main();				

		window.onload = function()
		{			
			gameMain.drawBackground();
			gameMain.drawObstacles();
			
			gameMain.hero.render();
			
			gameMain.renderMonsters();	
			
			gameMain.renderPotions();
		};
		
		document.onkeydown = function(event)
		{										
			gameMain.clearCanvas();					
			gameMain.drawBackground();				
			
			if(!gameMain.gameWon)			
			{
				gameMain.drawObstacles();

				gameMain.hero.update(event.keyCode);
				gameMain.hero.render();		
				
				gameMain.updateMonsters();
				gameMain.renderMonsters();	
				
				gameMain.renderPotions();		
			}
			
			if(gameMain.gameWon)	
			{
				gameMain.clearCanvas();					
				gameMain.drawBackground();
				gameMain.drawObstacles();
				
				gameMain.hero.render();	
				gameMain.renderMonsters();	
				gameMain.renderPotions();	
				
				gameMain.drawWinScreen();			
			}
		};			
	</script>
</html>

