<! --
		class for drawing
		class for hero
		class for enemies
		class for potions
		
		only global variables for:
			canvas object
			context2D			
			main		
			
		update hero:
			same thing, but if hero moves to enemy (after enemy moves), maintain position and lower enemy health
									
		
		hierarchy:
			Potion
			Character
				Hero
				// for move
				Monster
					// for renders
					Snowman 
					Void
					Golem
							
		Combat stuff:
			if hero and enemy move to same tile, enemy stays and both attack
			if hero and enemy both move and are adjacent after, both attack
			if enemy moves into obstacle and hero moves beside enemy, hero attack. vice versa for hero
			if enemy and hero both move into each other, both attack
			if enemy moves away from hero and hero chases enemy, hero attack
			
			enemy should stay still if hero moves to same tile
			enemy should stay still if hero and enemy move to each other
			
			hero updates and renders before enemies
				
		TODO:		
			COMBAT		
			POTIONS		
			DRAW GRID AND SHRINK IMAGES
-- >

<!doctype html>
<html>
	<script>						
		class Character
		{	
			x;
			y;
			
			hp;
			maxHp;
			
			atk;
			def;			

			pic;
			
			constructor()
			{							
				this.x = 1;
				this.y = 1;								
			}			

			drawHealth()
			{
				gameMain.setLineWidth(5);
				gameMain.setLineColor("#0F0");
				gameMain.setLineCap("butt");
				
				let hpPercent = this.hp/this.maxHp;								
				// change color with hp percent?
				
				context.beginPath();
				context.moveTo(64 * this.x + 12, 64 * this.y + 4);
				context.lineTo(64 * this.x + 12 + 40*hpPercent, 64 * this.y + 4);
				context.stroke();
			}
			
			getRandomInt(max)
			{	
				return Math.floor(Math.random()*(max+1));
			}		
			
			attack(character)
			{						
				let statDiff = this.atk - character.def;
				let max = Math.max(1, statDiff);
				let damage = max*(1 + this.getRandomInt(5));
				
				character.hp -= damage;
				if(character.hp <= 0)				
				{						
					// delete monster if dead
					gameMain.monsters = gameMain.monsters.filter(function(value) 
					{
						return value !== character;
					});
				}
			}
		}
		
		class Hero extends Character
		{			
			constructor()
			{
				super();	
				
				this.x = 1;
				this.y = 1;
				
				this.hp = 200;
				this.maxHp = 200;
				
				this.atk = 6;
				this.def = 4;
				
				this.pic = new Image();
				this.pic.src = "img/hero.png";				
			}			
			
			update(key)
			{	
				// left
				if(key == 37 && gameMain.grid[this.y][(this.x-1)] == 0)
				{
					if(gameMain.tileHasCharacter(this.x-1, this.y))
					{
						this.attack(gameMain.getCharacter(this.x-1, this.y));
					}
					else
					{
						this.x -= 1;
					}
				}
				// up
				else if(key == 38 && gameMain.grid[(this.y-1)][this.x] == 0)
				{
				    if(gameMain.tileHasCharacter(this.x, this.y-1))
					{
						this.attack(gameMain.getCharacter(this.x, this.y-1));
					}
					else
					{
						this.y -= 1;
					}
				}
				// right
				else if(key == 39 && gameMain.grid[this.y][(this.x+1)] == 0)
				{
				    if(gameMain.tileHasCharacter(this.x+1, this.y))
					{
						this.attack(gameMain.getCharacter(this.x+1, this.y));
					}
					else
					{
						this.x += 1;
					}
				}
				// down
				else if(key == 40 && gameMain.grid[(this.y+1)][this.x] == 0)						
				{
					if(gameMain.tileHasCharacter(this.x, this.y+1))
					{
						this.attack(gameMain.getCharacter(this.x, this.y+1));
					}
					else
					{
						this.y += 1;
					}
				}
				
				//this.hp += hpChange;
			}		
			
			render()
			{					
				// onload code so image shows properly once page is opened				
				context.drawImage(this.pic, 64 * this.x, 64 * this.y, 64, 64);		
				this.drawHealth();
			}		
		}
		
		class Monster extends Character
		{
			constructor()
			{
				super();
				
				this.x = 0;
				this.y = 0;
				
				this.hp = 100;
				this.maxHp = 100;
				
				this.atk = 3;
				this.def = 2;							
			}					
			
			update()
			{				
				let adjTiles = [];				
				
				// could use a list of tile offsets to make more concise
				if(gameMain.tileHasCharacter(this.x, this.y-1))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.grid[(this.y-1)][this.x] == 0)
				{
					adjTiles.push("top");
				}
				
				if(gameMain.tileHasCharacter(this.x+1, this.y))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.grid[this.y][this.x+1] == 0)
				{
					adjTiles.push("right");
				}
				
				if(gameMain.tileHasCharacter(this.x, this.y+1))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.grid[(this.y+1)][this.x] == 0)
				{
					adjTiles.push("bottom");
				}
				
				if(gameMain.tileHasCharacter(this.x-1, this.y))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.grid[this.y][this.x-1] == 0)
				{
					adjTiles.push("left");
				}																		
											
				let randIndx = this.getRandomInt(adjTiles.length);				
				
				switch(adjTiles[randIndx])
				{
					case "top":
						this.y -= 1;
						break;
					case "right":
						this.x += 1;
						break;
					case "bottom":
						this.y += 1;
						break;
					case "left":
						this.x -= 1;						
						break;
					case "hero":
						// attack
				}							
			}
		}
		
		class Snowman extends Monster
		{
			constructor()
			{
				super();
				
				this.x = 1;
				this.y = 6;
				
				this.hp = 100;
				this.maxHp = 100;
				
				this.atk = 3;	
				this.def = 3;		
				
				this.pic = new Image();
				this.pic.src = "img/snowMonster.png";
			}
			
			render()
			{						
				this.pic.onload = function()
				{										
					this.pic = new Image();	
					this.pic.src = "img/snowMonster.png";		

					context.drawImage(this.pic, 64 * this.x, 64 * this.y, 64, 64);		
				};
								
				context.drawImage(this.pic, 64 * this.x, 64 * this.y, 64, 64);		
				this.drawHealth();
			}
		}
		
		class Golem extends Monster
		{
			constructor()
			{
				super();
				
				this.x = 3;
				this.y = 1;
				
				this.hp = 150;
				this.maxHp = 150;
				
				this.atk = 2;
				this.def = 4;		
				
				this.pic = new Image();
				this.pic.src = "img/iceGolem.png";
			}
			
			render()
			{						
				this.pic.onload = function()
				{										
					this.pic = new Image();	
					this.pic.src = "img/iceGolem.png";		
					
					context.drawImage(this.pic, 64 * this.x, 64 * this.y, 64, 64);		
				};
								
				context.drawImage(this.pic, 64 * this.x, 64 * this.y, 64, 64);		
				this.drawHealth();
			}
		}
		
		class Void extends Monster
		{
			constructor()
			{
				super();
				
				this.x = 7;
				this.y = 3;
				
				this.hp = 80;
				this.maxHp = 80;
				
				this.atk = 5;
				this.def = 1;		
				
				this.pic = new Image();
				this.pic.src = "img/skullMonster.png";
			}
			
			render()
			{						
				this.pic.onload = function()
				{										
					this.pic = new Image();	
					this.pic.src = "img/skullMonster.png";		
					
					context.drawImage(this.pic, 64 * this.x, 64 * this.y, 64, 64);		
				};
								
				context.drawImage(this.pic, 64 * this.x, 64 * this.y, 64, 64);	
				this.drawHealth();				
			}
		}
		
		class main
		{
			hero;
			monsters = [];
			potions = [];
			grid = [ 
			['B', 'T', 'B', 'T', 'B', 'T', 'B', 'T', 'B', 'T'],
			['B', 0, 'B', 0, 0, 0, 0, 0, 0, 'B'],
			['B', 0, 'T', 'T', 0, 0, 0, 'B', 0, 'T'],
			['T', 0, 0, 0, 0, 'T', 0, 0, 0, 'B'],
			['B', 0, 0, 0, 0, 'B', 0, 'B', 0, 'T'],
			['T', 'B', 'T', 0, 0, 0, 0, 'T', 0, 'B'],
			['B', 0, 0, 0, 0, 0, 0, 0, 0, 'T'],
			['T', 'B', 'T', 'B', 'T', 'B', 'T', 'B', 'T', 'B'] 			
			];
			canvasWidth;
			canvasHeight;
			
			constructor()
			{						
				this.hero = new Hero();
				this.monsters.push(new Snowman());
				this.monsters.push(new Golem());
				this.monsters.push(new Void());
				
				this.canvasWidth = document.getElementsByTagName("canvas")[0].width;
				this.canvasHeight = document.getElementsByTagName("canvas")[0].height;																									
			}
			
			// returns x and y of first match to valueToFind
			getGridPosition(valueToFind) 
			{
				for (let i = 0; i < this.grid.length; i++) 
				{
					for (let j = 0; j < this.grid[i].length; j++) 
					{
						if (this.grid[i][j] === valueToFind)
							return { row: i, col: j };						
					}
				}				
				return null;
			}					
			
			initGrid()
			{			
				// why do potions and bricks overlap?
				// how to move hero and monsters
				
				for(let row = 0; row < this.grid.length; row++)
				{
					for(let col = 0; col < this.grid[row].length; col++)
					{
						switch(this.grid[row][col])
						{							
							case 'B':								
								this.drawBrick(col, row);
								break;
							case 'T':								
								this.drawTree(col, row);
								break;							
							case 'P':
								var potion = new Image();
								potion.src = "img/potion.png";
								context.drawImage(potion, col * 64, row * 64, 64, 64);
								break;
							case 'H':	
								this.hero = new Hero();
								this.hero.x = col;
								this.hero.y = row;
								this.hero.render();
								break;
							case 'S':
								this.monsters.push(new Snowman());									
								this.monsters[(this.monsters.length-1)].pic.src = "img/snowMonster.png";								
								this.monsters[(this.monsters.length-1)].x = col;
								this.monsters[(this.monsters.length-1)].y = row;
								this.monsters[(this.monsters.length-1)].render();																
								break;
							case 'V':
								this.monsters.push(new Void());																
								this.monsters[(this.monsters.length-1)].pic.src = "img/skullMonster.png";								
								this.monsters[(this.monsters.length-1)].x = col;
								this.monsters[(this.monsters.length-1)].y = row;
								this.monsters[(this.monsters.length-1)].render();								
								break;
							case 'G':
								this.monsters.push(new Golem());																
								this.monsters[(this.monsters.length-1)].pic.src = "img/iceGolem.png";								
								this.monsters[(this.monsters.length-1)].x = col;
								this.monsters[(this.monsters.length-1)].y = row;
								this.monsters[(this.monsters.length-1)].render();										
								break;		
								
								// put in potions later
						}
					}
				}								
			}
				
			getCharacter(x, y)
			{
				if(this.hero.x == x && this.hero.y == y)
					return this.hero;
					
				for(let i = 0; i < this.monsters.length; i++)
				{
					if(this.monsters[i].x == x && this.monsters[i].y == y)
						return this.monsters[i];
				}
				
				return "character not found";
			}
			
			drawBackground()
			{				
				this.setLineWidth(1000);
				this.setLineColor("#eef0bd");
				this.setLineCap("square");
				
				context.beginPath();
				context.moveTo(this.canvasWidth/2, this.canvasHeight/2);
				context.lineTo((this.canvasWidth/2)+1, (this.canvasHeight/2)+1);
				context.stroke();
			}
			
			drawObstacles()
			{
				for(let row = 0; row < this.grid.length; row++)
				{
					for(let col = 0; col < this.grid[row].length; col++)
					{
						switch(this.grid[row][col])
						{							
							case 'B':								
								this.drawBrick(col, row);
								break;
							case 'T':								
								this.drawTree(col, row);
								break;
						}
					}
				}
			}
			
			tileHasObstacle(x, y)
			{
				for(let i = 0; i < this.grid.length; i++)
				{
					for(let j = 0; j < this.grid[i].length; j++)
					{
						if(this.grid[i][j] == 'B' || this.grid[i][j] == 'T')
							return true;
					}					
				}
				return false;
			}
			
			tileHasCharacter(x, y)
			{
				for(let i = 0; i < this.monsters.length; i++)
				{
					if(this.monsters[i].x == x && this.monsters[i].y == y)
						return true;
					if(this.hero.x == x && this.hero.y == y)
						return true;
				}
				return false;
			}
			
			updateMonsters()
			{
				for(let i = 0; i < this.monsters.length; i++)				
					this.monsters[i].update();
			}
			
			renderMonsters()
			{
				for(let i = 0; i < this.monsters.length; i++)				
					this.monsters[i].render();
														
			}
			
			clearCanvas()
			{				
				console.log("clearing canvas");
				context.clearRect(0, 0, canvas.width, canvas.height);
			}
			
			setLineColor(color)
			{
				context.strokeStyle = color;
			}
			
			setFillColor(color)
			{
				context.fillStyle = color;
			}
			
			setLineWidth(width)
			{
				context.lineWidth = width;
			}
			
			setLineCap(str)
			{
				// options are butt, round, square
				context.lineCap = str;								
			}
			
			setLineJoin(c)
			{
				switch(c)
				{
					case 0: 
							context.lineJoin = "miter";
							break;
					case 1:
							context.lineJoin = "round";
							break;
					case 2:
							context.lineJoin = "bevel";
							break;
					default:
							break;
				}
			}					
			
			drawLine(x1, y1, x2, y2)
			{
				this.setLineWidth(1);
				this.setLineColor("#F00");
				this.setLineCap(0);
				
				context.beginPath();
				context.moveTo(x1,y1);
				context.lineTo(x2,y2);
				context.stroke();
			}
			
			drawBrick(x, y)
			{
				this.setLineWidth(32);
				this.setLineColor("#BC4A3C");
				this.setLineCap("square");					
				
				context.beginPath();
				context.moveTo(x*64 + 20, (y+1)*64 - 22);
				context.lineTo(x*64 + 44, (y+1)*64 - 22);
				context.stroke();				
			}
						
			drawTree(x, y)
			{
				this.setLineWidth(10);				
				this.setLineCap("round");
										
				// draw trunk
				context.beginPath();
				this.setLineColor("#a69f6c");
				context.moveTo(x*64 + 32, (y+1)*64);
				context.lineTo(x*64 + 32, (y+1)*64 - 22);
				context.moveTo(x*64 + 32, (y+1)*64 - 22);
				context.stroke();
				
				// draw leaves
				context.beginPath();
				this.setLineWidth(45);
				this.setLineColor("#45ad57");						
				context.lineTo(x*64 + 32, (y+1)*64 - 42);
				context.moveTo(x*64 + 32, (y+1)*64 - 42);
				context.stroke();						
				// add tree to 2d arr here or in advance?
			}											
		}
	</script>
		
	<canvas width=640 height=512 style="border: solid; border-color: black;">				
	</canvas>			
	
	<script>	
		var canvas = document.getElementsByTagName("canvas")[0];
		var context = canvas.getContext("2d");		
		var gameMain = new main();	

		window.onload = function()
		{
			gameMain.initGrid();
			gameMain.drawBackground();
			gameMain.drawObstacles();
			
			gameMain.hero.render();
			gameMain.renderMonsters();					
		};
		
		document.onkeydown = function(event)
		{			
			gameMain.clearCanvas();
			gameMain.drawBackground();				
			gameMain.drawObstacles();

			gameMain.hero.update(event.keyCode);
			gameMain.hero.render();		
			
			gameMain.updateMonsters();
			gameMain.renderMonsters();									
		};			
	</script>
</html>

