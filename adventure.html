<! --
		class for drawing
		class for hero
		class for enemies
		class for potions
		
		only global variables for:
			canvas object
			context2D			
			main
		
		updaing enemy:
			get list of adjacent tiles that don't have an obstacle or hero. isObstacle function?
			randomly pick an adjacent tile from the list
			call move function that incremenets/decrements position based on what tile was chosen
			update and render enemy
			
		update hero:
			same thing, but if hero moves to enemy (after enemy moves), maintain position and lower enemy health
			
			
		when arrow key pressed, update and render hero, enemies, and potions (delete potions if hero moves to them). Don't forget hp bars				
		
		hierarchy:
			Potion
			Character
				Hero
				// for move
				Monster
					// for renders
					Snowman 
					Void
					Golem
					
		approaches to ai:
			use conditionals in script to check tiles and call update when tile selected
			change update in character to differentiate between hero and monster. if monster, get tiles
			remove update from character and put different update function for hero and monster *
				
		TODO:		
			ENEMY AI
			POTIONS
			COMBAT
-- >

<!doctype html>
<html>
	<script>						
		class Character
		{	
			x;
			y;
			
			hp;
			maxHp;
			
			atk;
			def;
			
			pic;
			
			constructor()
			{							
				this.x = 0;
				this.y = 0;
				
				this.hp = 100;
				this.maxHp = 100;
				this.atk = 1;
				this.def = 1;

				this.pic = new Image();				
			}				
		}
		
		class Hero extends Character
		{					
			constructor()
			{
				super();	
				
				this.pic = new Image();
				this.pic.src = "img/hero.png";				
			}			

			render()
			{					
				// onload code so image shows properly once page is opened
				this.pic.onload = function()
				{										
					this.pic = new Image();
					this.pic.src = "img/hero.png";				
										
					let position = gameMain.getGridPosition('H');										
					context.drawImage(this.pic, 64 * position.col, 64 * position.row, 64, 64);	
				};
								
				context.drawImage(this.pic, this.x, this.y, 64, 64);		
			}			
			
			update(moveX, moveY, hpChange)
			{
				this.x += moveX;
				this.y += moveY;
				this.hp += hpChange;
			}	
		}
		
		class Monster extends Character
		{
			constructor()
			{
				super();
				
				this.x = 0;
				this.y = 0;
				
				this.hp = 0;
				this.maxHp = 0;
				
				this.atk = 0;
				this.def = 0;
				
				this.pic = 0;
			}
			
			getRandomInt(max)
			{	
				return Math.floor(Math.random()*(max+1));
			}
			
			update()
			{				
				let adjTiles = [];
								
				console.log("x: " + this.x + ", y: " + this.y);
				console.log("gameMain.grid[this.y][this.x]: " + gameMain.grid[this.y][this.x]);
				if(gameMain.grid[(this.y-1)][this.x] == 0)
				{
					adjTiles.push("top");
				}				
				else if(gameMain.grid[this.y][(this.x+1)] == 0)
				{
					adjTiles.push("right");
				}				
				else if(gameMain.grid[(this.y+1)][this.x] == 0)
				{
					adjTiles.push("bottom");
				}				
				else if(gameMain.grid[this.y][(this.x-1)] == 0)
				{
					adjTiles.push("left");
				}
							
				let randIndx = this.getRandomInt(adjTiles.length);
				
				switch(adjTiles(randIndx))
				{
					case "top":
						this.y -= 64;
						break;
					case "right":
						this.x += 64;
						break;
					case "bottom":
						this.y += 64;
						break;
					case "left":
						this.x -= 64;
						break;
				}							
			}
		}
		
		class Snowman extends Monster
		{
			constructor()
			{
				super();
				
				this.pic = new Image();
				this.pic.src = "img/snowMonster.png";
			}
			
			render()
			{						
				this.pic.onload = function()
				{										
					this.pic = new Image();	
					this.pic.src = "img/snowMonster.png";		

					let position = gameMain.getGridPosition('S');										
					context.drawImage(this.pic, 64 * position.col, 64 * position.row, 64, 64);		
				};
								
				context.drawImage(this.pic, 64 * this.x, 64 * this.y, 64, 64);		
			}
		}
		
		class Golem extends Monster
		{
			constructor()
			{
				super();
				
				this.pic = new Image();
				this.pic.src = "img/iceGolem.png";
			}
			
			render()
			{						
				this.pic.onload = function()
				{										
					this.pic = new Image();	
					this.pic.src = "img/iceGolem.png";		

					let position = gameMain.getGridPosition('G');					
					context.drawImage(this.pic, 64 * position.col, 64 * position.row, 64, 64);		
				};
								
				context.drawImage(this.pic, this.x, this.y, 64, 64);		
			}
		}
		
		class Void extends Monster
		{
			constructor()
			{
				super();
				
				this.pic = new Image();
				this.pic.src = "img/skullMonster.png";
			}
			
			render()
			{						
				this.pic.onload = function()
				{										
					this.pic = new Image();	
					this.pic.src = "img/skullMonster.png";		

					let position = gameMain.getGridPosition('V');									
					context.drawImage(this.pic, 64 * position.col, 64 * position.row, 64, 64);		
				};
								
				context.drawImage(this.pic, this.x, this.y, 64, 64);		
			}
		}
		
		class main
		{
			hero;
			monsters = [];
			potions = [];
			grid = [ 
			['B', 'T', 'B', 'T', 'B', 'T', 'B', 'T', 'B', 'T'],
			['B', 'H', 'B', 'G', 0, 0, 0, 0, 0, 'B'],
			['B', 0, 'T', 'T', 0, 0, 0, 'B', 0, 'T'],
			['T', 0, 0, 0, 0, 'T', 0, 0, 0, 'B'],
			['B', 0, 0, 0, 0, 'B', 'V', 'B', 0, 'T'],
			['T', 'B', 'T', 0, 0, 0, 0, 'T', 0, 'B'],
			['B', 'S', 0, 0, 'P', 0, 0, 0, 0, 'T'],
			['T', 'B', 'T', 'B', 'T', 'B', 'T', 'B', 'T', 'B'] 			
			];
			canvasWidth;
			canvasHeight;
			
			constructor()
			{												
				this.canvasWidth = document.getElementsByTagName("canvas")[0].width;
				this.canvasHeight = document.getElementsByTagName("canvas")[0].height;																									
			}
			
			// returns x and y of first match to valueToFind
			getGridPosition(valueToFind) 
			{
				for (let i = 0; i < this.grid.length; i++) 
				{
					for (let j = 0; j < this.grid[i].length; j++) 
					{
						if (this.grid[i][j] === valueToFind)
							return { row: i, col: j };						
					}
				}				
				return null;
			}					
			
			initGrid()
			{			
				// why do potions and bricks overlap?
				// how to move hero and monsters
				
				for(let row = 0; row < this.grid.length; row++)
				{
					for(let col = 0; col < this.grid[row].length; col++)
					{
						switch(this.grid[row][col])
						{							
							case 'B':								
								this.drawBrick(col, row);
								break;
							case 'T':								
								this.drawTree(col, row);
								break;							
							case 'P':
								var potion = new Image();
								potion.src = "img/potion.png";
								context.drawImage(potion, col * 64, row * 64, 64, 64);
								break;
							case 'H':	
								this.hero = new Hero();
								this.hero.x = col * 64;
								this.hero.y = row * 64;
								this.hero.render();
								break;
							case 'S':
								this.monsters.push(new Snowman());									
								this.monsters[(this.monsters.length-1)].pic.src = "img/snowMonster.png";								
								this.monsters[(this.monsters.length-1)].x = col * 64;
								this.monsters[(this.monsters.length-1)].y = row * 64;
								this.monsters[(this.monsters.length-1)].render();																
								break;
							case 'V':
								this.monsters.push(new Void());																
								this.monsters[(this.monsters.length-1)].pic.src = "img/skullMonster.png";								
								this.monsters[(this.monsters.length-1)].x = col * 64;
								this.monsters[(this.monsters.length-1)].y = row * 64;
								this.monsters[(this.monsters.length-1)].render();								
								break;
							case 'G':
								this.monsters.push(new Golem());																
								this.monsters[(this.monsters.length-1)].pic.src = "img/iceGolem.png";								
								this.monsters[(this.monsters.length-1)].x = col * 64;
								this.monsters[(this.monsters.length-1)].y = row * 64;
								this.monsters[(this.monsters.length-1)].render();										
								break;		
								
								// put in potions later
						}
					}
				}								
			}
			
			drawBackground()
			{
				this.setLineWidth(1000);
				this.setLineColor("#eef0bd");
				this.setLineCap(0);
				
				context.beginPath();
				context.moveTo(this.canvasWidth/2, this.canvasHeight/2);
				context.lineTo((this.canvasWidth/2)+1, (this.canvasHeight/2)+1);
				context.stroke();
			}
			
			drawObstacles()
			{
				for(let row = 0; row < this.grid.length; row++)
				{
					for(let col = 0; col < this.grid[row].length; col++)
					{
						switch(this.grid[row][col])
						{							
							case 'B':								
								this.drawBrick(col, row);
								break;
							case 'T':								
								this.drawTree(col, row);
								break;
						}
					}
				}
			}
			
			updateMonsters()
			{
				for(let i = 0; i < this.monsters.length; i++)				
					this.monsters[i].update();
			}
			
			renderMonsters()
			{
				for(let i = 0; i < this.monsters.length; i++)				
					this.monsters[i].render();
														
			}
			
			clearCanvas()
			{				
				console.log("clearing canvas");
				context.clearRect(0, 0, canvas.width, canvas.height);
			}
			
			setLineColor(color)
			{
				context.strokeStyle = color;
			}
			
			setFillColor(color)
			{
				context.fillStyle = color;
			}
			
			setLineWidth(width)
			{
				context.lineWidth = width;
			}
			
			setLineCap(str)
			{
				// options are butt, round, square
				context.lineCap = str;								
			}
			
			setLineJoin(c)
			{
				switch(c)
				{
					case 0: 
							context.lineJoin = "miter";
							break;
					case 1:
							context.lineJoin = "round";
							break;
					case 2:
							context.lineJoin = "bevel";
							break;
					default:
							break;
				}
			}					
			
			drawLine(x1, y1, x2, y2)
			{
				this.setLineWidth(1);
				this.setLineColor("#F00");
				this.setLineCap(0);
				
				context.beginPath();
				context.moveTo(x1,y1);
				context.lineTo(x2,y2);
				context.stroke();
			}
			
			drawBrick(x, y)
			{
				this.setLineWidth(32);
				this.setLineColor("#BC4A3C");
				this.setLineCap("square");					
				
				context.beginPath();
				context.moveTo(x*64 + 20, (y+1)*64 - 22);
				context.lineTo(x*64 + 44, (y+1)*64 - 22);
				context.stroke();				
			}
						
			drawTree(x, y)
			{
				this.setLineWidth(10);				
				this.setLineCap("round");
										
				// draw trunk
				context.beginPath();
				this.setLineColor("#a69f6c");
				context.moveTo(x*64 + 32, (y+1)*64);
				context.lineTo(x*64 + 32, (y+1)*64 - 22);
				context.moveTo(x*64 + 32, (y+1)*64 - 22);
				context.stroke();
				
				// draw leaves
				context.beginPath();
				this.setLineWidth(45);
				this.setLineColor("#45ad57");						
				context.lineTo(x*64 + 32, (y+1)*64 - 42);
				context.moveTo(x*64 + 32, (y+1)*64 - 42);
				context.stroke();						
				// add tree to 2d arr here or in advance?
			}											
		}
	</script>
		
	<canvas width=640 height=512 style="border: solid; border-color: black;">				
	</canvas>			
	
	<script>	
		var canvas = document.getElementsByTagName("canvas")[0];
		var context = canvas.getContext("2d");		
		var gameMain = new main();	

		window.onload = function()
		{
			gameMain.initGrid();
			gameMain.drawBackground();
			gameMain.drawObstacles();
			gameMain.hero.render();
			gameMain.renderMonsters();					
		};
		
		document.onkeydown = function(event)
		{			
			gameMain.clearCanvas();
			gameMain.drawBackground();
			
			switch (event.keyCode) 
			{
				// left
				case 37:					
					gameMain.hero.update(-64, 0, 0);					
					break;
				// up
				case 38:									
					gameMain.hero.update(0, -64, 0);					
					break;
				// right
				case 39:					
					gameMain.hero.update(64, 0, 0);			
					break;
				// down
				case 40:							
					gameMain.hero.update(0, 64, 0);										
					break;
			}			

			gameMain.drawObstacles();
			gameMain.hero.render();
			gameMain.updateMonsters();
			gameMain.renderMonsters();									
		};			
	</script>
</html>

