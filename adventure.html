<!doctype html>
<html>
	<script>						
		class Character
		{	
			x;
			y;
			
			hp;
			maxHp;
			
			atk;
			def;			

			pic;
			
			constructor()
			{							
				this.x = 1;
				this.y = 1;								
			}			

			drawHealth()
			{
				gameMain.setLineWidth(5);				
				gameMain.setLineCap("butt");
				
				let hpPercent = this.hp/this.maxHp;		

				if(hpPercent > 0.6)
				{
					gameMain.setLineColor("#0F0");
				}
				else if(hpPercent > 0.25)
				{
					gameMain.setLineColor("#FF0");
				}
				else if(hpPercent > 0)
				{
					gameMain.setLineColor("#F00");
				}				
				
				context.beginPath();
				context.moveTo(64 * this.x + 12, 64 * this.y + 4);
				context.lineTo(64 * this.x + 12 + 40*hpPercent, 64 * this.y + 4);
				context.stroke();
			}
			
			getRandomInt(max)
			{	
				return Math.floor(Math.random()*(max+1));
			}		
			
			attack(character)
			{						
				let statDiff = this.atk - character.def;
				let max = Math.max(1, statDiff);
				let damage = max*(1 + this.getRandomInt(5));
				
				character.hp -= damage;				
				if(character.hp <= 0)				
				{								
					// delete monster if dead
					gameMain.monsters = gameMain.monsters.filter(function(value) 
					{
						return value !== character;
					});
				}
			}
			
			render()
			{					
				// will character still exist on grid after death?
				if(this.hp > 0)
				{					
					context.drawImage(this.pic, 64 * this.x, 64 * this.y, 64, 64);	
					this.drawHealth();
				}
				else if(this.pic.src = "img/hero.png")
				{
					gameMain.gameLost = true;
				}							
			}
		}
		
		class Hero extends Character
		{			
			constructor()
			{
				super();	
				
				this.x = 1;
				this.y = 1;
				
				this.hp = 100;
				this.maxHp = 100;
				
				this.atk = 6;
				this.def = 3;
				
				this.pic = new Image();
				this.pic.src = "img/hero.png";				
			}			
			
			update(key)
			{	
				// left
				if(key == 37 && gameMain.grid[this.y][(this.x-1)] == 0)
				{
					if(gameMain.tileHasMonster(this.x-1, this.y))
					{
						this.attack(gameMain.getCharacter(this.x-1, this.y));
					}
					else
					{
						this.x -= 1;
					}
				}
				// up
				else if(key == 38 && gameMain.grid[(this.y-1)][this.x] == 0)
				{
				    if(gameMain.tileHasMonster(this.x, this.y-1))
					{
						this.attack(gameMain.getCharacter(this.x, this.y-1));
					}
					else
					{
						this.y -= 1;
					}
				}
				// right
				else if(key == 39 && gameMain.grid[this.y][(this.x+1)] == 0)
				{
				    if(gameMain.tileHasMonster(this.x+1, this.y))
					{
						this.attack(gameMain.getCharacter(this.x+1, this.y));
					}
					else
					{
						this.x += 1;
					}
				}
				// down
				else if(key == 40 && gameMain.grid[(this.y+1)][this.x] == 0)						
				{
					if(gameMain.tileHasMonster(this.x, this.y+1))
					{
						this.attack(gameMain.getCharacter(this.x, this.y+1));
					}
					else
					{
						this.y += 1;
					}
				}				

				if(gameMain.tileHasPotion(this.x, this.y))
				{
					let potion = gameMain.getPotion(this.x, this.y);
					
					// add health up to max
					if(this.hp + Potion.hpBoost > this.maxHp)	
					{						
						this.hp = this.maxHp;
					}
					else
					{					
						this.hp += Potion.hpBoost;
					}
						
					// delete potion										
					gameMain.potions = gameMain.potions.filter(function(value) 
					{
						return value !== potion;
					});
				}
			}					
		}
		
		class Monster extends Character
		{
			constructor()
			{
				super();
				
				this.x = 0;
				this.y = 0;
				
				this.hp = 100;
				this.maxHp = 100;
				
				this.atk = 3;
				this.def = 2;							
			}					
			
			update()
			{				
				let adjTiles = [];				
							
				if(gameMain.tileHasHero(this.x, (this.y-1)))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.tileOpen(this.x, (this.y-1)))
				{
					adjTiles.push("top");
				}
				
				if(gameMain.tileHasHero((this.x+1), this.y))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.tileOpen((this.x+1), this.y))
				{
					adjTiles.push("right");
				}
				
				if(gameMain.tileHasHero(this.x, (this.y+1)))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.tileOpen(this.x, (this.y+1)))
				{
					adjTiles.push("bottom");
				}
				
				if(gameMain.tileHasHero((this.x-1), this.y))
				{
					adjTiles.push("hero");
				}
				else if(gameMain.tileOpen((this.x-1), this.y))
				{
					adjTiles.push("left");
				}																		
											
				let randIndx = this.getRandomInt(adjTiles.length);			
				
				switch(adjTiles[randIndx])
				{
					case "top":
						this.y -= 1;
						break;
					case "right":
						this.x += 1;
						break;
					case "bottom":
						this.y += 1;
						break;
					case "left":
						this.x -= 1;						
						break;
					case "hero":
						this.attack(gameMain.hero);
						break;
				}							
			}
		}
		
		class Snowman extends Monster
		{
			constructor()
			{
				super();
				
				this.x = 1;
				this.y = 6;
				
				this.hp = 100;
				this.maxHp = 100;
				
				this.atk = 3;	
				this.def = 3;		
				
				this.pic = new Image();
				this.pic.src = "img/snowMonster.png";
			}			
		}
		
		class Golem extends Monster
		{
			constructor()
			{
				super();
				
				this.x = 3;
				this.y = 1;
				
				this.hp = 100;
				this.maxHp = 100;
				
				this.atk = 3;
				this.def = 4;		
				
				this.pic = new Image();
				this.pic.src = "img/iceGolem.png";
			}			
		}
		
		class Void extends Monster
		{
			constructor()
			{
				super();
				
				this.x = 7;
				this.y = 3;
				
				this.hp = 80;
				this.maxHp = 80;
				
				this.atk = 5;
				this.def = 2;		
				
				this.pic = new Image();
				this.pic.src = "img/skullMonster.png";
			}			
		}
		
		class Potion
		{
			x;
			y;
			static hpBoost = 50;
			
			pic;
			
			constructor()
			{				
				this.pic = new Image();
				this.pic.src = "img/potion.png";
			}
			
			render()
			{							
				context.drawImage(this.pic, 64 * this.x + 10, 64 * this.y + 16, 44, 44);												
			}
		}
		
		class main
		{
			hero;
			monsters = [];
			potions = [];
			grid = [ 
			['B', 'T', 'B', 'T', 'B', 'T', 'B', 'T', 'B', 'T'],
			['B', 0, 'B', 0, 0, 0, 0, 0, 0, 'B'],
			['B', 0, 'T', 'T', 0, 0, 0, 'B', 0, 'T'],
			['T', 0, 0, 0, 0, 'T', 0, 0, 0, 'B'],
			['B', 0, 0, 0, 0, 'B', 0, 'B', 0, 'T'],
			['T', 'B', 'T', 0, 0, 0, 0, 'T', 0, 'B'],
			['B', 0, 0, 0, 0, 0, 0, 0, 0, 'T'],
			['T', 'B', 'T', 'B', 'T', 'B', 'T', 'B', 'T', 'B'] 			
			];
			gameWon;
			gameLost;
			
			canvasWidth;
			canvasHeight;
			
			constructor()
			{						
				this.hero = new Hero();
				this.monsters.push(new Snowman());
				this.monsters.push(new Golem());
				this.monsters.push(new Void());
				
				this.potions.push(new Potion());
				this.potions[0].x = 8;
				this.potions[0].y = 6;
				
				this.potions.push(new Potion());
				this.potions[1].x = 5;
				this.potions[1].y = 1;
				
				this.gameWon = false;
				this.gameLost = false;
				
				this.canvasWidth = document.getElementsByTagName("canvas")[0].width;
				this.canvasHeight = document.getElementsByTagName("canvas")[0].height;																									
			}
			
			// returns x and y of first match to valueToFind
			getGridPosition(valueToFind) 
			{
				for (let i = 0; i < this.grid.length; i++) 
				{
					for (let j = 0; j < this.grid[i].length; j++) 
					{
						if (this.grid[i][j] === valueToFind)
							return { row: i, col: j };						
					}
				}				
				return null;
			}							
				
			getCharacter(x, y)
			{
				if(this.hero.x == x && this.hero.y == y)
					return this.hero;
					
				for(let i = 0; i < this.monsters.length; i++)
				{
					if(this.monsters[i].x == x && this.monsters[i].y == y)
						return this.monsters[i];
				}
				
				return "character not found";
			}
			
			getPotion(x, y)
			{
				for(let i = 0; i < this.potions.length; i++)
				{
					if(this.potions[i].x == x && this.potions[i].y == y)
						return this.potions[i];
				}
				
				return "potion not found";
			}
			
			drawBackground()
			{				
				this.setLineWidth(1000);
				this.setLineColor("#eef0bd");
				this.setLineCap("square");
				
				context.beginPath();
				context.moveTo(this.canvasWidth/2, this.canvasHeight/2);
				context.lineTo((this.canvasWidth/2)+1, (this.canvasHeight/2)+1);
				context.stroke();
			}
			
			drawObstacles()
			{
				for(let row = 0; row < this.grid.length; row++)
				{
					for(let col = 0; col < this.grid[row].length; col++)
					{
						switch(this.grid[row][col])
						{							
							case 'B':								
								this.drawBrick(col, row);
								break;
							case 'T':								
								this.drawTree(col, row);
								break;
						}
					}
				}
			}
			
			tileOpen(x, y)
			{
				if(this.grid[y][x] !== 0)
						return false;	
						
				for(let i = 0; i < this.monsters.length; i++)
				{
					if(this.monsters[i].x == x && this.monsters[i].y == y)
						return false;										
				}
				
				if(this.hero.x == x && this.hero.y == y)
						return false;																				
				
				return true;
			}
			
			tileHasHero(x, y)
			{
				for(let i = 0; i < this.monsters.length; i++)
				{					
					if(this.hero.x == x && this.hero.y == y)
						return true;
				}
				return false;
			}
			
			tileHasMonster(x, y)
			{
				for(let i = 0; i < this.monsters.length; i++)
				{
					if(this.monsters[i].x == x && this.monsters[i].y == y)
						return true;					
				}
				return false;
			}
			
			tileHasPotion(x, y)
			{
				for(let i = 0; i < this.potions.length; i++)
				{
					if(this.potions[i].x == x && this.potions[i].y == y)
						return true;
				}
				return false;
			}
			
			updateMonsters()
			{
				for(let i = 0; i < this.monsters.length; i++)				
					this.monsters[i].update();
					
				if(this.monsters.length == 0)
					this.gameWon = true;
			}	
			
			renderMonsters()
			{
				for(let i = 0; i < this.monsters.length; i++)				
					this.monsters[i].render();
			}
			
			renderPotions()
			{
				for(let i = 0; i < this.potions.length; i++)				
					this.potions[i].render();			
			}
			
			clearCanvas()
			{								
				context.clearRect(0, 0, canvas.width, canvas.height);
			}
			
			setLineColor(color)
			{
				context.strokeStyle = color;
			}
			
			setFillColor(color)
			{
				context.fillStyle = color;
			}
			
			setLineWidth(width)
			{
				context.lineWidth = width;
			}
			
			setLineCap(str)
			{
				// options are butt, round, square
				context.lineCap = str;								
			}
			
			setLineJoin(c)
			{
				switch(c)
				{
					case 0: 
							context.lineJoin = "miter";
							break;
					case 1:
							context.lineJoin = "round";
							break;
					case 2:
							context.lineJoin = "bevel";
							break;
					default:
							break;
				}
			}					
			
			drawLine(x1, y1, x2, y2)
			{
				this.setLineWidth(1);
				this.setLineColor("#F00");
				this.setLineCap(0);
				
				context.beginPath();
				context.moveTo(x1,y1);
				context.lineTo(x2,y2);
				context.stroke();
			}
			
			drawBrick(x, y)
			{
				this.setLineWidth(32);
				this.setLineColor("#BC4A3C");
				this.setLineCap("square");					
				
				context.beginPath();
				context.moveTo(x*64 + 20, (y+1)*64 - 22);
				context.lineTo(x*64 + 44, (y+1)*64 - 22);
				context.stroke();				
			}
						
			drawTree(x, y)
			{
				this.setLineWidth(10);				
				this.setLineCap("square");
										
				// draw trunk
				context.beginPath();
				this.setLineColor("#a69f6c");
				context.moveTo(x*64 + 32, (y+1)*64 - 8);
				context.lineTo(x*64 + 32, (y+1)*64 - 22);
				context.moveTo(x*64 + 32, (y+1)*64 - 22);
				context.stroke();
				
				// draw leaves
				context.beginPath();
				this.setLineCap("round");
				this.setLineWidth(40);
				this.setLineColor("#45ad57");						
				context.lineTo(x*64 + 32, (y+1)*64 - 42);
				context.moveTo(x*64 + 32, (y+1)*64 - 42);
				context.stroke();										
			}				

			drawWinScreen()
			{				
				let fontSize = 110;
				context.font = fontSize + 'px Arial';
				context.fillStyle = 'black';						
				
				let xOffset = this.canvasWidth/(fontSize/18);
				
				var message = 'You win!';
				context.fillText(message, xOffset, this.canvasHeight/2 + 20);
			}
			
			drawLoseScreen()
			{
				let fontSize = 110;
				context.font = fontSize + 'px Arial';
				context.fillStyle = 'black';						
				
				let xOffset = this.canvasWidth/(fontSize/7);
				
				var message = 'Game Over';
				context.fillText(message, xOffset, this.canvasHeight/2 + 20);
			}
			
			drawGrid()
			{
				this.setLineWidth(1);				
				this.setLineCap("square");
				this.setLineColor("#000");
				
				for(let x = 1; x < 10; x++)
				{					
					context.beginPath();
					context.moveTo(64 * x, 0);
					context.lineTo(64 * x, this.canvasHeight);	
					context.stroke();
				}
				
				for(let y = 1; y < 8; y++)
				{					
					context.beginPath();
					context.moveTo(0, 64 * y);
					context.lineTo(this.canvasWidth, 64 * y);	
					context.stroke();
				}
			}
		}
	</script>
		
	<canvas width=640 height=512 style="border: solid; border-color: black;">				
	</canvas>			
	
	<script>	
		var canvas = document.getElementsByTagName("canvas")[0];
		var context = canvas.getContext("2d");		
		var gameMain = new main();				

		window.onload = function()
		{			
			gameMain.drawBackground();
			gameMain.drawObstacles();
			
			gameMain.hero.render();
			gameMain.renderMonsters();	
			gameMain.renderPotions();
			//gameMain.drawGrid();
		};
		
		document.onkeydown = function(event)
		{										
			gameMain.clearCanvas();					
			gameMain.drawBackground();					
			
			if(!gameMain.gameWon && !gameMain.gameLost)			
			{
				gameMain.drawObstacles();

				gameMain.hero.update(event.keyCode);
				gameMain.hero.render();		
				
				gameMain.updateMonsters();
				gameMain.renderMonsters();	
				
				gameMain.renderPotions();		
			}
			
			if(gameMain.gameWon || gameMain.gameLost)			
			{
				gameMain.clearCanvas();					
				gameMain.drawBackground();
				gameMain.drawObstacles();
				
				gameMain.hero.render();	
				gameMain.renderMonsters();	
				gameMain.renderPotions();	
			
				if(gameMain.gameWon)			
				{
					gameMain.drawWinScreen();
				}			
				else
				{
					gameMain.drawLoseScreen();			
				}
			}			
		};			
	</script>
</html>

