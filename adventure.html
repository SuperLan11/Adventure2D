<! --
		class for drawing
		class for hero
		class for enemies
		class for potions
		
		only global variables for:
			canvas object
			context2D			
			main
		
		
		updaing enemy:
			get list of adjacent tiles that don't have an obstacle or hero. isObstacle function?
			randomly pick an adjacent tile from the list
			call move function that incremenets/decrements position based on what tile was chosen
			update and render enemy
			
		update hero:
			same thing, but if hero moves to enemy (after enemy moves), maintain position and lower enemy health
			
			
		when arrow key pressed, update and render hero, enemies, and potions (delete potions if hero moves to them). Don't forget hp bars				
		
		hierarchy:
			Potion
			Character
				Hero
				Snowman
				Void
				Golem
				
		MAKE TREES 64X64
		FIX OBSTACLE ROW OFFSET
		ADD ENEMY AI
		ADD COMBAT
-- >

<!doctype html>
<html>
	<script>						
		class Character
		{	
			x;
			y;
			
			hp;
			maxHp;
			
			atk;
			def;
			
			pic;
			
			constructor()
			{							
				this.x = 0;
				this.y = 0;
				
				this.hp = 100;
				this.maxHp = 100;
				this.atk = 1;
				this.def = 1;

				this.pic = new Image();				
			}
		
			update(moveX, moveY, hpChange)
			{
				this.x += moveX;
				this.y += moveY;
				this.hp += hpChange;
			}					
		}
		
		class Hero extends Character
		{					
			constructor()
			{
				super();	
				
				this.pic = new Image();
				this.pic.src = "img/hero.png";				
			}			

			render()
			{					
				// onload code so image shows properly once page is opened
				this.pic.onload = function()
				{										
					this.pic = new Image();
					this.pic.src = "img/hero.png";				
										
					let position = gameMain.getGridPosition('H');										
					context.drawImage(this.pic, 64 * position.col, 64 * position.row, 64, 64);	
				};
								
				context.drawImage(this.pic, this.x, this.y, 64, 64);		
			}			
		}
		
		class Snowman extends Character
		{
			constructor()
			{
				super();
				
				this.pic = new Image();
				this.pic.src = "img/snowMonster.png";
			}
			
			render()
			{						
				this.pic.onload = function()
				{										
					this.pic = new Image();	
					this.pic.src = "img/snowMonster.png";		

					let position = gameMain.getGridPosition('S');										
					context.drawImage(this.pic, 64 * position.col, 64 * position.row, 64, 64);		
				};
								
				context.drawImage(this.pic, this.x, this.y, 64, 64);		
			}
		}
		
		class Golem extends Character
		{
			constructor()
			{
				super();
				
				this.pic = new Image();
				this.pic.src = "img/iceGolem.png";
			}
			
			render()
			{						
				this.pic.onload = function()
				{										
					this.pic = new Image();	
					this.pic.src = "img/iceGolem.png";		

					let position = gameMain.getGridPosition('G');					
					context.drawImage(this.pic, 64 * position.col, 64 * position.row, 64, 64);		
				};
								
				context.drawImage(this.pic, this.x, this.y, 64, 64);		
			}
		}
		
		class Void extends Character
		{
			constructor()
			{
				super();
				
				this.pic = new Image();
				this.pic.src = "img/skullMonster.png";
			}
			
			render()
			{						
				this.pic.onload = function()
				{										
					this.pic = new Image();	
					this.pic.src = "img/skullMonster.png";		

					let position = gameMain.getGridPosition('V');									
					context.drawImage(this.pic, 64 * position.col, 64 * position.row, 64, 64);		
				};
				
				console.log("rendering " + this.pic.src);
				context.drawImage(this.pic, this.x, this.y, 64, 64);		
			}
		}
		
		class main
		{
			hero;
			monsters = [];
			potions = [];
			grid = [ 
			['B', 'T', 'B', 'T', 'B', 'T', 'B', 'T', 'B', 'T'],
			['B', 'H', 'B', 'G', 0, 0, 0, 0, 0, 'B'],
			['B', 0, 'T', 'T', 0, 0, 0, 'B', 0, 'T'],
			['T', 0, 0, 0, 0, 'T', 0, 0, 0, 'B'],
			['B', 0, 0, 0, 0, 'B', 'V', 'B', 0, 'T'],
			['T', 'B', 'T', 0, 0, 0, 0, 'T', 0, 'B'],
			['B', 'S', 0, 0, 'P', 0, 0, 0, 0, 'T'],
			['T', 0, 'T', 'B', 0, 0, 0, 0, 0, 0] 			
			];
			canvasWidth;
			canvasHeight;
			
			constructor()
			{												
				this.canvasWidth = document.getElementsByTagName("canvas")[0].width;
				this.canvasHeight = document.getElementsByTagName("canvas")[0].height;																									
			}
			
			// returns x and y of first match to valueToFind
			getGridPosition(valueToFind) 
			{
				for (let i = 0; i < this.grid.length; i++) 
				{
					for (let j = 0; j < this.grid[i].length; j++) 
					{
						if (this.grid[i][j] === valueToFind)
							return { row: i, col: j };						
					}
				}				
				return null;
			}					
			
			initGrid()
			{			
				// why do potions and bricks overlap? obstacles are offset?									
				// how to move hero and monsters
				
				for(let row = 0; row < this.grid.length; row++)
				{
					for(let col = 0; col < this.grid[row].length; col++)
					{
						switch(this.grid[row][col])
						{							
							case 'B':								
								this.drawBrick(col, row);
								break;
							case 'T':								
								this.drawTree(col, row);
								break;							
							case 'P':
								var potion = new Image();
								potion.src = "img/potion.png";
								context.drawImage(potion, col * 64, row * 64, 64, 64);
								break;
							case 'H':	
								this.hero = new Hero();
								this.hero.x = col * 64;
								this.hero.y = row * 64;
								this.hero.render();
								break;
							case 'S':
								this.monsters.push(new Snowman());									
								this.monsters[(this.monsters.length-1)].pic.src = "img/snowMonster.png";								
								this.monsters[(this.monsters.length-1)].x = col * 64;
								this.monsters[(this.monsters.length-1)].y = row * 64;
								this.monsters[(this.monsters.length-1)].render();																
								break;
							case 'V':
								this.monsters.push(new Void());																
								this.monsters[(this.monsters.length-1)].pic.src = "img/skullMonster.png";								
								this.monsters[(this.monsters.length-1)].x = col * 64;
								this.monsters[(this.monsters.length-1)].y = row * 64;
								this.monsters[(this.monsters.length-1)].render();								
								break;
							case 'G':
								this.monsters.push(new Golem());																
								this.monsters[(this.monsters.length-1)].pic.src = "img/iceGolem.png";								
								this.monsters[(this.monsters.length-1)].x = col * 64;
								this.monsters[(this.monsters.length-1)].y = row * 64;
								this.monsters[(this.monsters.length-1)].render();										
								break;		
								
								// put in potions later
						}
					}
				}								
			}
			
			drawObstacles()
			{
				for(let row = 0; row < this.grid.length; row++)
				{
					for(let col = 0; col < this.grid[row].length; col++)
					{
						switch(this.grid[row][col])
						{							
							case 'B':								
								this.drawBrick(col, row);
								break;
							case 'T':								
								this.drawTree(col, row);
								break;
						}
					}
				}
			}
			
			renderMonsters()
			{
				for(let i = 0; i < this.monsters.length; i++)				
					this.monsters[i].render();
														
			}
			
			clearCanvas()
			{				
				console.log("clearing canvas");
				context.clearRect(0, 0, canvas.width, canvas.height);
			}
			
			setLineColor(color)
			{
				context.strokeStyle = color;
			}
			
			setFillColor(color)
			{
				context.fillStyle = color;
			}
			
			setLineWidth(width)
			{
				context.lineWidth = width;
			}
			
			setLineCap(str)
			{
				// options are butt, round, square
				context.lineCap = str;								
			}
			
			setLineJoin(c)
			{
				switch(c)
				{
					case 0: 
							context.lineJoin = "miter";
							break;
					case 1:
							context.lineJoin = "round";
							break;
					case 2:
							context.lineJoin = "bevel";
							break;
					default:
							break;
				}
			}					
			
			drawLine(x1, y1, x2, y2)
			{
				this.setLineWidth(1);
				this.setLineColor("#F00");
				this.setLineCap(0);
				
				context.beginPath();
				context.moveTo(x1,y1);
				context.lineTo(x2,y2);
				context.stroke();
			}
			
			drawBrick(x, y)
			{
				this.setLineWidth(32);
				this.setLineColor("#BC4A3C");
				this.setLineCap("square");					
				
				context.beginPath();
				context.moveTo(x*64 + 20, y*64);
				context.lineTo(x*64 + 44, y*64);
				context.stroke();				
			}
						
			drawTree(x, y)
			{
				this.setLineWidth(12);				
				this.setLineCap("round");
										
				// draw trunk
				context.beginPath();
				this.setLineColor("#a69f6c");
				context.moveTo(x*64 + 32, y*64);
				context.lineTo(x*64 + 32, y*64 - 32);
				context.moveTo(x*64 + 32, y*64 - 32);
				context.stroke();
				
				// draw leaves
				context.beginPath();
				this.setLineWidth(50);
				this.setLineColor("#45ad57");						
				context.lineTo(x*64 + 32, y*64 - 48);
				context.moveTo(x*64 + 32, y*64 - 48);
				context.stroke();						
				// add tree to 2d arr here or in advance?
			}											
		}
	</script>
		
	<canvas width=640 height=512 style="border: solid; border-color: black;">				
	</canvas>			
	
	<script>	
		var canvas = document.getElementsByTagName("canvas")[0];
		var context = canvas.getContext("2d");		
		var gameMain = new main();	

		window.onload = function()
		{
			gameMain.initGrid();
			gameMain.drawObstacles();
			gameMain.hero.render();
			gameMain.renderMonsters();		
		};
		
		document.onkeydown = function(event)
		{			
			gameMain.clearCanvas();
			
			switch (event.keyCode) 
			{
				// left
				case 37:					
					gameMain.hero.update(-64, 0, 0);					
					break;
				// up
				case 38:									
					gameMain.hero.update(0, -64, 0);					
					break;
				// right
				case 39:					
					gameMain.hero.update(64, 0, 0);			
					break;
				// down
				case 40:							
					gameMain.hero.update(0, 64, 0);										
					break;
			}			

			gameMain.drawObstacles();
			gameMain.hero.render();
			gameMain.renderMonsters();									
		};			
	</script>
</html>

